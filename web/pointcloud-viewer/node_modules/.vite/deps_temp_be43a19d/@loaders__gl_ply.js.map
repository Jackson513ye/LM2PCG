{
  "version": 3,
  "sources": ["../../@loaders.gl/ply/dist/ply-loader.js", "../../@loaders.gl/ply/dist/lib/get-ply-schema.js", "../../@loaders.gl/ply/dist/lib/normalize-ply.js", "../../@loaders.gl/ply/dist/lib/parse-ply.js", "../../@loaders.gl/ply/dist/lib/parse-ply-in-batches.js", "../../@loaders.gl/ply/dist/index.js"],
  "sourcesContent": ["// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n/**\n * Worker loader for PLY - Polygon File Format (aka Stanford Triangle Format)'\n * links: ['http://paulbourke.net/dataformats/ply/',\n * 'https://en.wikipedia.org/wiki/PLY_(file_format)']\n */\nexport const PLYLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'PLY',\n    id: 'ply',\n    module: 'ply',\n    // shapes: ['mesh', 'gltf', 'columnar-table'],\n    version: VERSION,\n    worker: true,\n    extensions: ['ply'],\n    mimeTypes: ['text/plain', 'application/octet-stream'],\n    text: true,\n    binary: true,\n    tests: ['ply'],\n    options: {\n        ply: {}\n    }\n};\n", "import { deduceMeshSchema } from '@loaders.gl/schema';\n/**\n * Gets schema from PLY header\n * @param plyHeader\n * @param metadata\n * @returns Schema\n */\nexport function getPLYSchema(plyHeader, attributes) {\n    const metadata = makeMetadataFromPlyHeader(plyHeader);\n    const schema = deduceMeshSchema(attributes, metadata);\n    return schema;\n}\n/**\n * Make arrow like schema metadata by PlyHeader properties\n * @param plyHeader\n * @returns\n */\nfunction makeMetadataFromPlyHeader(plyHeader) {\n    /* eslint-disable camelcase */\n    const metadata = {};\n    metadata.ply_comments = JSON.stringify(plyHeader.comments);\n    metadata.ply_elements = JSON.stringify(plyHeader.elements);\n    if (plyHeader.format !== undefined) {\n        metadata.ply_format = plyHeader.format;\n    }\n    if (plyHeader.version !== undefined) {\n        metadata.ply_version = plyHeader.version;\n    }\n    if (plyHeader.headerLength !== undefined) {\n        metadata.ply_headerLength = plyHeader.headerLength.toString(10);\n    }\n    return metadata;\n}\n", "import { getMeshBoundingBox } from '@loaders.gl/schema';\nimport { getPLYSchema } from \"./get-ply-schema.js\";\n/**\n * @param header\n * @param attributes\n * @returns data and header\n */\nexport default function normalizePLY(plyHeader, plyAttributes, options) {\n    const attributes = getMeshAttributes(plyAttributes);\n    const boundingBox = getMeshBoundingBox(attributes);\n    const vertexCount = plyAttributes.indices.length || plyAttributes.vertices.length / 3;\n    // TODO - how to detect POINT CLOUDS vs MESHES?\n    // TODO - For Meshes, PLY quadrangles must be split?\n    const isTriangles = plyAttributes.indices && plyAttributes.indices.length > 0;\n    const mode = isTriangles ? 4 : 0; // TRIANGLES vs POINTS\n    const topology = isTriangles ? 'triangle-list' : 'point-list';\n    const schema = getPLYSchema(plyHeader, attributes);\n    const plyMesh = {\n        loader: 'ply',\n        loaderData: plyHeader,\n        header: {\n            vertexCount,\n            boundingBox\n        },\n        schema,\n        attributes,\n        indices: { value: new Uint32Array(0), size: 0 },\n        mode,\n        topology\n    };\n    if (plyAttributes.indices.length > 0) {\n        plyMesh.indices = { value: new Uint32Array(plyAttributes.indices), size: 1 };\n    }\n    return plyMesh;\n}\n/**\n * @param attributes\n * @returns accessors []\n */\n// eslint-disable-next-line complexity\nfunction getMeshAttributes(attributes) {\n    const accessors = {};\n    for (const attributeName of Object.keys(attributes)) {\n        switch (attributeName) {\n            case 'vertices':\n                if (attributes.vertices.length > 0) {\n                    accessors.POSITION = { value: new Float32Array(attributes.vertices), size: 3 };\n                }\n                break;\n            // optional attributes data\n            case 'normals':\n                if (attributes.normals.length > 0) {\n                    accessors.NORMAL = { value: new Float32Array(attributes.normals), size: 3 };\n                }\n                break;\n            case 'uvs':\n                if (attributes.uvs.length > 0) {\n                    accessors.TEXCOORD_0 = { value: new Float32Array(attributes.uvs), size: 2 };\n                }\n                break;\n            case 'colors':\n                if (attributes.colors.length > 0) {\n                    // TODO - normalized shoud be based on `uchar` flag in source data?\n                    accessors.COLOR_0 = { value: new Uint8Array(attributes.colors), size: 3, normalized: true };\n                }\n                break;\n            case 'indices':\n                break;\n            default:\n                if (attributes[attributeName].length > 0) {\n                    accessors[attributeName] = { value: new Float32Array(attributes[attributeName]), size: 1 };\n                }\n                break;\n        }\n    }\n    return accessors;\n}\n", "import normalizePLY from \"./normalize-ply.js\";\n/**\n * @param data\n * @param options\n * @returns\n */\nexport function parsePLY(data, options = {}) {\n    let header;\n    let attributes;\n    if (data instanceof ArrayBuffer) {\n        const text = new TextDecoder().decode(data);\n        header = parseHeader(text, options);\n        attributes = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n    }\n    else {\n        header = parseHeader(data, options);\n        attributes = parseASCII(data, header);\n    }\n    return normalizePLY(header, attributes);\n}\n/**\n * @param data\n * @param options\n * @returns header\n */\nfunction parseHeader(data, options) {\n    const PLY_HEADER_PATTERN = /ply([\\s\\S]*)end_header\\s/;\n    let headerText = '';\n    let headerLength = 0;\n    const result = PLY_HEADER_PATTERN.exec(data);\n    if (result !== null) {\n        headerText = result[1];\n        headerLength = result[0].length;\n    }\n    const lines = headerText.split('\\n');\n    const header = parseHeaderLines(lines, headerLength, options);\n    return header;\n}\n/**\n * @param lines\n * @param headerLength\n * @param options\n * @returns header\n */\n// eslint-disable-next-line complexity\nfunction parseHeaderLines(lines, headerLength, options) {\n    const header = {\n        comments: [],\n        elements: [],\n        headerLength\n    };\n    let lineType;\n    let lineValues;\n    let currentElement = null;\n    for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === '') {\n            // eslint-disable-next-line\n            continue;\n        }\n        lineValues = line.split(/\\s+/);\n        lineType = lineValues.shift();\n        line = lineValues.join(' ');\n        switch (lineType) {\n            case 'format':\n                header.format = lineValues[0];\n                header.version = lineValues[1];\n                break;\n            case 'comment':\n                header.comments.push(line);\n                break;\n            case 'element':\n                // Start new element, store previous element\n                if (currentElement) {\n                    header.elements.push(currentElement);\n                }\n                currentElement = {\n                    name: lineValues[0],\n                    count: parseInt(lineValues[1], 10),\n                    properties: []\n                };\n                break;\n            case 'property':\n                if (currentElement) {\n                    const property = makePLYElementProperty(lineValues);\n                    if (options?.propertyNameMapping && property.name in options?.propertyNameMapping) {\n                        property.name = options?.propertyNameMapping[property.name];\n                    }\n                    currentElement.properties.push(property);\n                }\n                break;\n            default:\n                // eslint-disable-next-line\n                console.log('unhandled', lineType, lineValues);\n        }\n    }\n    // Store in-progress element\n    if (currentElement) {\n        header.elements.push(currentElement);\n    }\n    return header;\n}\n/** Generate attributes arrays from the header */\n// eslint-disable-next-line complexity\nfunction getPLYAttributes(header) {\n    // TODO Generate only the attribute arrays actually in the header\n    const attributes = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        colors: []\n    };\n    for (const element of header.elements) {\n        if (element.name === 'vertex') {\n            for (const property of element.properties) {\n                switch (property.name) {\n                    case 'x':\n                    case 'y':\n                    case 'z':\n                    case 'nx':\n                    case 'ny':\n                    case 'nz':\n                    case 's':\n                    case 't':\n                    case 'red':\n                    case 'green':\n                    case 'blue':\n                        break;\n                    default:\n                        // Add any non-geometry attributes\n                        attributes[property.name] = [];\n                        break;\n                }\n            }\n        }\n    }\n    return attributes;\n}\n/**\n * @param propertyValues\n * @returns property of ply element\n */\nfunction makePLYElementProperty(propertyValues) {\n    const type = propertyValues[0];\n    switch (type) {\n        case 'list':\n            return {\n                type,\n                name: propertyValues[3],\n                countType: propertyValues[1],\n                itemType: propertyValues[2]\n            };\n        default:\n            return {\n                type,\n                name: propertyValues[1]\n            };\n    }\n}\n/**\n * Parses ASCII number\n * @param n\n * @param type\n * @returns\n */\n// eslint-disable-next-line complexity\nfunction parseASCIINumber(n, type) {\n    switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n            return parseInt(n, 10);\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n            return parseFloat(n);\n        default:\n            throw new Error(type);\n    }\n}\n/**\n * @param properties\n * @param line\n * @returns ASCII element\n */\nfunction parsePLYElement(properties, line) {\n    const values = line.split(/\\s+/);\n    const element = {};\n    for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n            const list = [];\n            const n = parseASCIINumber(values.shift(), properties[i].countType);\n            for (let j = 0; j < n; j++) {\n                list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n            }\n            element[properties[i].name] = list;\n        }\n        else {\n            element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n    }\n    return element;\n}\n/**\n * @param data\n * @param header\n * @returns [attributes]\n */\nfunction parseASCII(data, header) {\n    // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n    const attributes = getPLYAttributes(header);\n    let result;\n    const patternBody = /end_header\\s([\\s\\S]*)$/;\n    let body = '';\n    if ((result = patternBody.exec(data)) !== null) {\n        body = result[1];\n    }\n    const lines = body.split('\\n');\n    let currentElement = 0;\n    let currentElementCount = 0;\n    for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line !== '') {\n            if (currentElementCount >= header.elements[currentElement].count) {\n                currentElement++;\n                currentElementCount = 0;\n            }\n            const element = parsePLYElement(header.elements[currentElement].properties, line);\n            handleElement(attributes, header.elements[currentElement].name, element);\n            currentElementCount++;\n        }\n    }\n    return attributes;\n}\n/**\n * @param buffer\n * @param elementName\n * @param element\n */\n// eslint-disable-next-line complexity\nfunction handleElement(buffer, elementName, element = {}) {\n    if (elementName === 'vertex') {\n        for (const propertyName of Object.keys(element)) {\n            switch (propertyName) {\n                case 'x':\n                    buffer.vertices.push(element.x, element.y, element.z);\n                    break;\n                case 'y':\n                case 'z':\n                    break;\n                case 'nx':\n                    if ('nx' in element && 'ny' in element && 'nz' in element) {\n                        buffer.normals.push(element.nx, element.ny, element.nz);\n                    }\n                    break;\n                case 'ny':\n                case 'nz':\n                    break;\n                case 's':\n                    if ('s' in element && 't' in element) {\n                        buffer.uvs.push(element.s, element.t);\n                    }\n                    break;\n                case 't':\n                    break;\n                case 'red':\n                    if ('red' in element && 'green' in element && 'blue' in element) {\n                        buffer.colors.push(element.red, element.green, element.blue);\n                    }\n                    break;\n                case 'green':\n                case 'blue':\n                    break;\n                default:\n                    buffer[propertyName].push(element[propertyName]);\n            }\n        }\n    }\n    else if (elementName === 'face') {\n        const vertexIndices = element.vertex_indices || element.vertex_index; // issue #9338\n        if (vertexIndices.length === 3) {\n            buffer.indices.push(vertexIndices[0], vertexIndices[1], vertexIndices[2]);\n        }\n        else if (vertexIndices.length === 4) {\n            buffer.indices.push(vertexIndices[0], vertexIndices[1], vertexIndices[3]);\n            buffer.indices.push(vertexIndices[1], vertexIndices[2], vertexIndices[3]);\n        }\n    }\n}\n/**\n * Reads binary data\n * @param dataview\n * @param at\n * @param type\n * @param littleEndian\n * @returns [number, number]\n */\n// eslint-disable-next-line complexity\nfunction binaryRead(dataview, at, type, littleEndian) {\n    switch (type) {\n        // corespondences for non-specific length types here match rply:\n        case 'int8':\n        case 'char':\n            return [dataview.getInt8(at), 1];\n        case 'uint8':\n        case 'uchar':\n            return [dataview.getUint8(at), 1];\n        case 'int16':\n        case 'short':\n            return [dataview.getInt16(at, littleEndian), 2];\n        case 'uint16':\n        case 'ushort':\n            return [dataview.getUint16(at, littleEndian), 2];\n        case 'int32':\n        case 'int':\n            return [dataview.getInt32(at, littleEndian), 4];\n        case 'uint32':\n        case 'uint':\n            return [dataview.getUint32(at, littleEndian), 4];\n        case 'float32':\n        case 'float':\n            return [dataview.getFloat32(at, littleEndian), 4];\n        case 'float64':\n        case 'double':\n            return [dataview.getFloat64(at, littleEndian), 8];\n        default:\n            throw new Error(type);\n    }\n}\n/**\n * Reads binary data\n * @param dataview\n * @param at\n * @param properties\n * @param littleEndian\n * @returns [object, number]\n */\nfunction binaryReadElement(dataview, at, properties, littleEndian) {\n    const element = {};\n    let result;\n    let read = 0;\n    for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n            const list = [];\n            result = binaryRead(dataview, at + read, properties[i].countType, littleEndian);\n            const n = result[0];\n            read += result[1];\n            for (let j = 0; j < n; j++) {\n                result = binaryRead(dataview, at + read, properties[i].itemType, littleEndian);\n                // @ts-ignore\n                list.push(result[0]);\n                read += result[1];\n            }\n            element[properties[i].name] = list;\n        }\n        else {\n            result = binaryRead(dataview, at + read, properties[i].type, littleEndian);\n            element[properties[i].name] = result[0];\n            read += result[1];\n        }\n    }\n    return [element, read];\n}\n/**\n * Parses binary data\n * @param data\n * @param header\n * @returns [attributes] of data\n */\nfunction parseBinary(data, header) {\n    const attributes = getPLYAttributes(header);\n    const littleEndian = header.format === 'binary_little_endian';\n    const body = new DataView(data, header.headerLength);\n    let result;\n    let loc = 0;\n    for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        const count = header.elements[currentElement].count;\n        for (let currentElementCount = 0; currentElementCount < count; currentElementCount++) {\n            result = binaryReadElement(body, loc, header.elements[currentElement].properties, littleEndian);\n            loc += result[1];\n            const element = result[0];\n            handleElement(attributes, header.elements[currentElement].name, element);\n        }\n    }\n    return attributes;\n}\n", "// PLY Loader, adapted from THREE.js (MIT license)\n//\n// Attributions per original THREE.js source file:\n//\n// @author Wei Meng / http://about.me/menway\n//\n// Description: A loader for PLY ASCII files (known as the Polygon File Format\n// or the Stanford Triangle Format).\n//\n// Limitations: ASCII decoding assumes file is UTF-8.\n//\n// If the PLY file uses non standard property names, they can be mapped while\n// loading. For example, the following maps the properties\n// “diffuse_(red|green|blue)” in the file to standard color names.\n//\n// parsePLY(data, {\n//   propertyNameMapping: {\n//     diffuse_red: 'red',\n//     diffuse_green: 'green',\n//     diffuse_blue: 'blue'\n//   }\n// });\nimport { makeLineIterator, makeTextDecoderIterator, forEach } from '@loaders.gl/loader-utils';\nimport normalizePLY from \"./normalize-ply.js\";\nlet currentElement;\n/**\n * PARSER\n * @param iterator\n * @param options\n */\nexport async function* parsePLYInBatches(iterator, options) {\n    const lineIterator = makeLineIterator(makeTextDecoderIterator(iterator));\n    const header = await parsePLYHeader(lineIterator, options);\n    let attributes;\n    switch (header.format) {\n        case 'ascii':\n            attributes = await parseASCII(lineIterator, header);\n            break;\n        default:\n            throw new Error('Binary PLY can not yet be parsed in streaming mode');\n        // attributes = await parseBinary(lineIterator, header);\n    }\n    yield normalizePLY(header, attributes, options);\n}\n/**\n * Parses header\n * @param lineIterator\n * @param options\n * @returns\n */\nasync function parsePLYHeader(lineIterator, options) {\n    const header = {\n        comments: [],\n        elements: []\n        // headerLength\n    };\n    // Note: forEach does not reset iterator if exiting loop prematurely\n    // so that iteration can continue in a second loop\n    await forEach(lineIterator, (line) => {\n        line = line.trim();\n        // End of header\n        if (line === 'end_header') {\n            return true; // Returning true cancels `forEach`\n        }\n        // Ignore empty lines\n        if (line === '') {\n            // eslint-disable-next-line\n            return false; // Returning false does not cancel `forEach`\n        }\n        const lineValues = line.split(/\\s+/);\n        const lineType = lineValues.shift();\n        line = lineValues.join(' ');\n        switch (lineType) {\n            case 'ply':\n                // First line magic characters, ignore\n                break;\n            case 'format':\n                header.format = lineValues[0];\n                header.version = lineValues[1];\n                break;\n            case 'comment':\n                header.comments.push(line);\n                break;\n            case 'element':\n                if (currentElement) {\n                    header.elements.push(currentElement);\n                }\n                currentElement = {\n                    name: lineValues[0],\n                    count: parseInt(lineValues[1], 10),\n                    properties: []\n                };\n                break;\n            case 'property':\n                const property = makePLYElementProperty(lineValues, options.propertyNameMapping);\n                currentElement.properties.push(property);\n                break;\n            default:\n                // eslint-disable-next-line\n                console.log('unhandled', lineType, lineValues);\n        }\n        return false;\n    });\n    if (currentElement) {\n        header.elements.push(currentElement);\n    }\n    return header;\n}\nfunction makePLYElementProperty(propertyValues, propertyNameMapping) {\n    const type = propertyValues[0];\n    switch (type) {\n        case 'list':\n            return {\n                type,\n                name: propertyValues[3],\n                countType: propertyValues[1],\n                itemType: propertyValues[2]\n            };\n        default:\n            return {\n                type,\n                name: propertyValues[1]\n            };\n    }\n}\n// ASCII PARSING\n/**\n * @param lineIterator\n * @param header\n * @returns\n */\nasync function parseASCII(lineIterator, header) {\n    // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n    const attributes = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        colors: []\n    };\n    let currentElement = 0;\n    let currentElementCount = 0;\n    for await (let line of lineIterator) {\n        line = line.trim();\n        if (line !== '') {\n            if (currentElementCount >= header.elements[currentElement].count) {\n                currentElement++;\n                currentElementCount = 0;\n            }\n            const element = parsePLYElement(header.elements[currentElement].properties, line);\n            handleElement(attributes, header.elements[currentElement].name, element);\n            currentElementCount++;\n        }\n    }\n    return attributes;\n}\n/**\n * Parses ASCII number\n * @param n\n * @param type\n * @returns ASCII number\n */\n// eslint-disable-next-line complexity\nfunction parseASCIINumber(n, type) {\n    switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n            return parseInt(n, 10);\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n            return parseFloat(n);\n        default:\n            throw new Error(type);\n    }\n}\n/**\n * Parses ASCII element\n * @param properties\n * @param line\n * @returns element\n */\nfunction parsePLYElement(properties, line) {\n    const values = line.split(/\\s+/);\n    const element = {};\n    for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n            const list = [];\n            const n = parseASCIINumber(values.shift(), properties[i].countType);\n            for (let j = 0; j < n; j++) {\n                list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n            }\n            element[properties[i].name] = list;\n        }\n        else {\n            element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n    }\n    return element;\n}\n/**\n * @param buffer\n * @param elementName\n * @param element\n */\n// HELPER FUNCTIONS\n// eslint-disable-next-line complexity\nfunction handleElement(buffer, elementName, element = {}) {\n    switch (elementName) {\n        case 'vertex':\n            buffer.vertices.push(element.x, element.y, element.z);\n            if ('nx' in element && 'ny' in element && 'nz' in element) {\n                buffer.normals.push(element.nx, element.ny, element.nz);\n            }\n            if ('s' in element && 't' in element) {\n                buffer.uvs.push(element.s, element.t);\n            }\n            if ('red' in element && 'green' in element && 'blue' in element) {\n                buffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0);\n            }\n            break;\n        case 'face':\n            const vertexIndices = element.vertex_indices || element.vertex_index; // issue #9338\n            if (vertexIndices.length === 3) {\n                buffer.indices.push(vertexIndices[0], vertexIndices[1], vertexIndices[2]);\n            }\n            else if (vertexIndices.length === 4) {\n                buffer.indices.push(vertexIndices[0], vertexIndices[1], vertexIndices[3]);\n                buffer.indices.push(vertexIndices[1], vertexIndices[2], vertexIndices[3]);\n            }\n            break;\n        default:\n            break;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { PLYLoader as PLYWorkerLoader } from \"./ply-loader.js\";\nimport { parsePLY } from \"./lib/parse-ply.js\";\nimport { parsePLYInBatches } from \"./lib/parse-ply-in-batches.js\";\nexport { PLYWorkerLoader };\n/**\n * Loader for PLY - Polygon File Format\n */\nexport const PLYLoader = {\n    ...PLYWorkerLoader,\n    // Note: parsePLY supports both text and binary\n    parse: async (arrayBuffer, options) => parsePLY(arrayBuffer, options?.ply), // TODO - this may not detect text correctly?\n    parseTextSync: (arrayBuffer, options) => parsePLY(arrayBuffer, options?.ply),\n    parseSync: (arrayBuffer, options) => parsePLY(arrayBuffer, options?.ply),\n    parseInBatches: (arrayBuffer, options) => parsePLYInBatches(arrayBuffer, options?.ply)\n};\n"],
  "mappings": "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",
  "names": ["currentElement", "parseASCII", "makePLYElementProperty", "currentElement", "parsePLYElement", "handleElement", "parseASCIINumber", "PLYLoader"]
}
